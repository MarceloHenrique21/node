import fs from 'fs/promises'
import PokemonModel from './pokemon.schema'

/* 
É inicializada uma variável moves como um array vazio para armazenar os movimentos selecionados aleatoriamente.

Em um loop while, o código verifica se o comprimento do array moves é diferente de 4. Isso significa que o loop continuará até que tenhamos 4 movimentos selecionados.

Dentro do loop, é gerado um número aleatório, randomNumber, usando Math.random() e Math.floor(). A função Math.random() retorna um número aleatório entre 0 (inclusivo) e 1 (exclusivo), e Math.floor() arredonda esse número para baixo para obter um número inteiro.

É feita uma verificação para garantir que o movimento selecionado aleatoriamente não esteja presente no array moves. Se já estiver presente, o movimento não será adicionado novamente.

Se o movimento selecionado passar pela verificação, ele é adicionado ao array moves.

O loop continua até que tenhamos 4 movimentos únicos no array moves.

Por fim, a função retorna o array moves com os 4 movimentos aleatórios selecionados.

Portanto, essa função recebe uma lista de movimentos e retorna uma lista com 4 movimentos selecionados aleatoriamente, garantindo que não haja repetições.
*/
function getRandomMoves(movesList) {
    const moves: Object[] = []

    while(moves.length != 4){
        let randomNumber = Math.floor(Math.random() * movesList.length)

        if(!moves.includes(moves[randomNumber])){
            moves.push(movesList[randomNumber])
        }
    }

    return moves
}

class PokemonService {
    async consumirPokeData() {

/*
   - Nesta linha, está sendo realizado uma requisição HTTP usando a função `fetch()` para obter dados de uma API em `http://localhost:3000/pokemons-data`.
   - O resultado da requisição é convertido para o formato JSON através do método `.json()`.
   - Em seguida, é utilizado o método `.then()` para acessar o resultado da conversão e aplicar o método `.slice(0, 10)`, que retorna apenas os primeiros 10 elementos da resposta. Essa operação limita a quantidade de pokémons obtidos para 10.
*/
        const pokemons = await fetch('http://localhost:3000/pokemons-data').then(response => response.json()).then(response => response.slice(0, 10))
        
/*
   - Nesta parte, o array de pokémons obtidos na etapa anterior é percorrido utilizando o método `map()`.
   - Para cada pokémon, é criado um novo objeto contendo algumas informações específicas, como nome, tipo, status, número na Pokédex, altura, peso e uma seleção aleatória de movimentos.
*/
        const mappedPokemons = pokemons.map(pokemon => {
            return {
                nome: pokemon.name,
                tipo: pokemon.types[0].type.name,
                status: pokemon.stats,
                numDex: pokemon.game_indices[9].game_index,
                altura: pokemon.height,
                peso: pokemon.weight,
                moves: getRandomMoves(pokemon.moves)
            }
        })

/*   
   - A função `fs.writeFile()` é usada para escrever os dados dos pokémons em um arquivo chamado 'pokemon.json'.
   - Os dados são convertidos para o formato JSON usando `JSON.stringify()` e são formatados com espaçamento de 2 caracteres para facilitar a leitura.

   */
        await fs.writeFile('pokemon.json', JSON.stringify(mappedPokemons, null, 2))

/*
4. `await PokemonModel.insertMany(mappedPokemons)`:
- É realizada uma operação de inserção no banco de dados utilizando o modelo `PokemonModel`.
- A função `insertMany()` insere vários documentos (no caso, os pokémons mapeados) em uma coleção do banco de dados.
 */
        await PokemonModel.insertMany(mappedPokemons)
    }

    async pokemonsByType() {

/*
1. `const pokemons = await fs.readFile('pokemon.json', {encoding: 'utf-8'}).then(response => JSON.parse(response))`:
   - Nesta linha, está sendo lido um arquivo chamado 'pokemon.json' usando a função `readFile` do módulo `fs` (que geralmente é usado para trabalhar com arquivos no Node.js).
   - O arquivo é lido com a codificação 'utf-8', o que significa que ele será interpretado como texto.
   - A função `readFile` retorna uma Promise, portanto, é usado o `await` para esperar a conclusão da leitura do arquivo.
   - Em seguida, o método `then` é encadeado para analisar o conteúdo do arquivo como JSON, convertendo-o em um objeto JavaScript.
*/
        const pokemons = await fs.readFile('pokemon.json', {encoding: 'utf-8'}).then(response => JSON.parse(response))



/*
2. `const pokemonsByType = pokemons.reduce((pokemonsByType, currentPokemon) => { ... })`:
   - Nesta linha, está sendo utilizado o método `reduce` no array `pokemons` (que foi obtido do arquivo JSON lido anteriormente).
   - O `reduce` é usado para percorrer cada elemento do array `pokemons` e acumular os resultados em um objeto chamado `pokemonsByType`.
   - A função de callback passada para o `reduce` é executada para cada elemento do array e recebe o acumulador (`pokemonsByType`) e o elemento atual (`currentPokemon`).
   - A lógica dentro da função de callback verifica se já existe um array para o tipo de Pokémon atual em `pokemonsByType`. Se não existir, cria-se um array vazio.
   - O Pokémon atual (`currentPokemon`) é então adicionado ao array correspondente ao seu tipo em `pokemonsByType`.
   - No final, o objeto `pokemonsByType` é retornado e atribuído à constante `pokemonsByType`.
*/
        const pokemonsByType = pokemons.reduce((pokemonsByType, currentPokemon) => {
            pokemonsByType[currentPokemon.tipo] = pokemonsByType[currentPokemon.tipo] || []
            pokemonsByType[currentPokemon.tipo].push(currentPokemon)
            return pokemonsByType
        }, {})


/*
3. `await fs.writeFile('pokemonsByType.json', JSON.stringify(pokemonsByType, null, 2))`:
   - Nesta linha, é usado o método `writeFile` do módulo `fs` para escrever um arquivo chamado 'pokemonsByType.json'.
   - O conteúdo do arquivo é gerado a partir do objeto `pokemonsByType` convertido em uma string JSON usando `JSON.stringify`.
   - O terceiro parâmetro de `stringify` é `2`, que especifica a quantidade de espaços de indentação para formatar o JSON de saída.
   - A função `writeFile` também retorna uma Promise, então o `await` é usado para aguardar a conclusão da escrita do arquivo.
*/
        await fs.writeFile('pokemonsByType.json', JSON.stringify(pokemonsByType, null, 2))


/*
4. `return pokemonsByType`:
   - Por fim, o objeto `pokemonsByType` é retornado como resultado da função `pokemonsByType()`. Isso significa que, quando a função for chamada, o resultado será o objeto `pokemonsByType`.

Em resumo, essa função lê um arquivo JSON contendo informações de Pokémon, agrupa-os por tipo em um objeto `pokemonsByType`, escreve esses dados em um novo arquivo JSON chamado 'pokemonsByType.json' e, em seguida, retorna o objeto `pokemonsByType`.
*/
        return pokemonsByType
    }


/*
Essas três funções são assíncronas e estão relacionadas a consultas em um banco de dados usando o `PokemonModel`. Vou explicar cada uma delas separadamente:

1. `async getPokemonsByType(type) { ... }`:
   - Esta função recebe um parâmetro `type` que representa o tipo de Pokémon a ser buscado.
   - Ela usa o `PokemonModel.find` para realizar uma consulta no banco de dados.
   - A consulta é feita procurando por documentos que tenham o campo `tipo` igual ao valor fornecido em `type`.
   - O `await` é usado para esperar a conclusão da consulta assíncrona.
   - Em seguida, o resultado da consulta é retornado.

2. `async getPokemonsByNumDex(numDex) { ... }`:
   - Esta função recebe um parâmetro `numDex` que representa o número da Pokédex do Pokémon a ser buscado.
   - Ela também usa o `PokemonModel.find` para fazer uma consulta no banco de dados.
   - A consulta é realizada procurando por documentos que tenham o campo `numDex` igual ao valor fornecido em `numDex`.
   - O `await` é usado para aguardar a conclusão da consulta assíncrona.
   - Em seguida, o resultado da consulta é retornado.

3. `async getPokemonsByNome(nome) { ... }`:
   - Esta função recebe um parâmetro `nome` que representa o nome do Pokémon a ser buscado.
   - Assim como as duas funções anteriores, ela utiliza o `PokemonModel.find` para realizar uma consulta no banco de dados.
   - A consulta é feita procurando por documentos que tenham o campo `nome` igual ao valor fornecido em `nome`.
   - Novamente, o `await` é utilizado para esperar a conclusão da consulta assíncrona.
   - Em seguida, o resultado da consulta é retornado.

Em resumo, essas funções assíncronas fornecem uma maneira de buscar Pokémon com base em diferentes critérios no banco de dados representado pelo `PokemonModel`. Através dessas funções, é possível obter Pokémon por tipo, número da Pokédex ou nome. Cada função realiza uma consulta no banco de dados e retorna o resultado correspondente à consulta.
*/
    async getPokemonsByType(type) {
        return await PokemonModel.find({tipo: type})
    }

    async getPokemonsByNumDex(numDex) {
        return await PokemonModel.find({numDex})
    }

    async getPokemonsByNome(nome) {
        return await PokemonModel.find({nome})
    }
}

export default new PokemonService()


